#include "abi.h"
#include <assert.h>
#include <string.h>
#include <stdint.h>
#include <stdio.h>

// Examples come from the spec: https://docs.soliditylang.org/en/develop/abi-spec.html#examples

// 1: function baz(uint32 x, bool y)
ABI_t ex1_abi[2] = {
  { .type = ABI_UINT32 },
  { .type = ABI_BOOL }
};
uint8_t ex1_encoded[68] = {
  0xcd, 0xcd, 0x77, 0xc0, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
};
uint32_t ex1_param_0 = 69;
bool ex1_param_1 = true;

// 2: function bar(bytes3[2])
ABI_t ex2_abi[1] = {
  { .type = ABI_BYTES3, .isArray = true, .arraySz = 2 }
};
uint8_t ex2_encoded[68] = {
  0xfc, 0xe3, 0x53, 0xf6, 
  0x61, 0x62, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x64, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
uint8_t ex2_param_0[6] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66 };

// 3: function sam(bytes, bool, uint[])
ABI_t ex3_abi[3] = {
  { .type = ABI_BYTES },
  { .type = ABI_BOOL },
  { .type = ABI_UINT, .isArray = true }
};
uint8_t ex3_encoded[292] = {
  0xa5, 0x64, 0x3b, 0xf2, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, // 4 "BYTES"
  0x64, 0x61, 0x76, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // 3 "UINT"
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03
};
uint8_t ex3_param_0[4] = { 0x64, 0x61, 0x76, 0x65 };
bool ex3_param_1 = true;
uint8_t ex3_param_2[96] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03
};

// 4: f(uint,uint32[],bytes10,bytes)
ABI_t ex4_abi[4] = {
  { .type = ABI_UINT },
  { .type = ABI_UINT32, .isArray = true },
  { .type = ABI_BYTES10 },
  { .type = ABI_BYTES }
};

uint8_t ex4_encoded[292] = {
  0x8b, 0xe6, 0x52, 0x46, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x56, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x89, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 
  0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
uint8_t ex4_param_0[32] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23, 
};
uint32_t ex4_param_1[2] = { 1110, 1929 };
uint8_t ex4_param_2[10] = { 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30 };
uint8_t ex4_param_3[13] = { 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21 };

static inline uint32_t get_u32_be(uint8_t * in, size_t off) {
  return (in[off + 3] | in[off + 2] << 8 | in[off + 1] << 16 | in[off + 0] << 24);
}

int main() {
  printf("=============================\n\r");
  printf(" RUNNING ABI TESTS...\n\r");
  printf("=============================\n\r");
  uint8_t out[200] = {0};
  // NOTE: We always add a 4-byte offset (e.g. `ex1_encoded+4`) to account for the function signature,
  // which is not part of the data we are trying to decode.
  // NOTE: The values we are checking come from the examples web page, but you can also validate them
  // manually from the payloads above.

  printf("Example 1...");
  // function baz(uint32 x, bool y)
  assert(abi_decode_param(out, sizeof(out), ex1_abi, 0, ex1_encoded+4) == sizeof(ex1_param_0));
  assert((out[3] | out[2] << 8 | out[1] << 16 | out[0] << 24) == ex1_param_0);
  memset(out, 0, sizeof(out));
  assert(abi_decode_param(out, sizeof(out), ex1_abi, 1, ex1_encoded+4) == sizeof(ex1_param_1));
  assert((bool) out[0] == ex1_param_1);
  memset(out, 0, sizeof(out));
  printf("passed.\n\r");

  printf("Example 2...");
  // function bar(bytes3[2])
  assert(abi_decode_param(out, sizeof(out), ex2_abi, 0, ex2_encoded+4) == sizeof(ex2_param_0));
  assert(0 == memcmp(ex2_param_0, out, sizeof(ex2_param_0)));
  memset(out, 0, sizeof(out));
  printf("passed.\n\r");

  printf("Example 3...");
  // function sam(bytes, bool, uint[])
  assert(abi_decode_param(out, sizeof(out), ex3_abi, 0, ex3_encoded+4) == sizeof(ex3_param_0)); // 4 bytes in payload
  assert(0 == memcmp(ex3_param_0, out, sizeof(ex3_param_0)));
  memset(out, 0, sizeof(out));
  assert(abi_decode_param(out, sizeof(out), ex3_abi, 1, ex3_encoded+4) == sizeof(ex3_param_1)); // 1 byte for bool
  assert((bool) out[0] == ex3_param_1);
  memset(out, 0, sizeof(out));
  assert(abi_decode_param(out, sizeof(out), ex3_abi, 2, ex3_encoded+4) == sizeof(ex3_param_2)); // 3 uint values, each 32 bytes
  assert(0 == memcmp(ex3_param_2, out, sizeof(ex3_param_2)));
  memset(out, 0, sizeof(out));
  printf("passed.\n\r");

  printf("Example 4...");
  // f(uint,uint32[],bytes10,bytes)
  assert(abi_decode_param(out, sizeof(out), ex4_abi, 0, ex4_encoded+4) == sizeof(ex4_param_0)); // uint = uint256 = 32 bytes
  assert(0 == memcmp(ex4_param_0, out, sizeof(ex4_param_0)));
  memset(out, 0, sizeof(out));
  assert(abi_decode_param(out, sizeof(out), ex4_abi, 1, ex4_encoded+4) == sizeof(ex4_param_1)); // 2x uint32 (see payload)
  assert(get_u32_be(out, 0) == ex4_param_1[0]);
  assert(get_u32_be(out, 4) == ex4_param_1[1]);
  memset(out, 0, sizeof(out));
  assert(abi_decode_param(out, sizeof(out), ex4_abi, 2, ex4_encoded+4) == sizeof(ex4_param_2)); // bytes10 = 10 bytes
  assert(0 == memcmp(ex4_param_2, out, sizeof(ex4_param_2)));
  memset(out, 0, sizeof(out));
  assert(abi_decode_param(out, sizeof(out), ex4_abi, 3, ex4_encoded+4) == sizeof(ex4_param_3)); // 0x0d = 13 bytes
  assert(0 == memcmp(ex4_param_3, out, sizeof(ex4_param_3)));
  memset(out, 0, sizeof(out));
  printf("passed.\n\r");

  printf("=============================\n\r");
  printf(" ALL ABI TESTS PASSING!\n\r");
  printf("=============================\n\r");
  
  return 0;
}
