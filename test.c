#include "abi.h"
#include <assert.h>
#include <string.h>
#include <stdint.h>
#include <stdio.h>

//===============================================================
// EXAMPLES
// (From the spec: https://docs.soliditylang.org/en/develop/abi-spec.html#examples)
//===============================================================

// 1: function baz(uint32 x, bool y)
ABI_t ex1_abi[2] = {
  { .type = ABI_UINT32 },
  { .type = ABI_BOOL }
};
uint8_t ex1_encoded[68] = {
  0xcd, 0xcd, 0x77, 0xc0, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
};
uint32_t ex1_param_0 = 69;
bool ex1_param_1 = true;

// 2: function bar(bytes3[2])
ABI_t ex2_abi[1] = {
  { .type = ABI_BYTES3, .isArray = true, .arraySz = 2 }
};
uint8_t ex2_encoded[68] = {
  0xfc, 0xe3, 0x53, 0xf6, 
  0x61, 0x62, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x64, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
uint8_t ex2_param_00[3] = { 0x61, 0x62, 0x63 };
uint8_t ex2_param_01[3] = { 0x64, 0x65, 0x66 };

// 3: function sam(bytes, bool, uint[])
ABI_t ex3_abi[3] = {
  { .type = ABI_BYTES },
  { .type = ABI_BOOL },
  { .type = ABI_UINT, .isArray = true }
};
uint8_t ex3_encoded[292] = {
  0xa5, 0x64, 0x3b, 0xf2, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, // 4 "BYTES"
  0x64, 0x61, 0x76, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // 3 "UINT"
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03
};
uint8_t ex3_param_0[4] = { 0x64, 0x61, 0x76, 0x65 };
bool ex3_param_1 = true;
uint8_t ex3_param_20[32] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
};
uint8_t ex3_param_21[32] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
};
uint8_t ex3_param_22[32] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03
};

// 4: f(uint,uint32[],bytes10,bytes)
ABI_t ex4_abi[4] = {
  { .type = ABI_UINT },
  { .type = ABI_UINT32, .isArray = true },
  { .type = ABI_BYTES10 },
  { .type = ABI_BYTES }
};

uint8_t ex4_encoded[292] = {
  0x8b, 0xe6, 0x52, 0x46,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x56,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x89,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d,
  0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
uint8_t ex4_param_0[32] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23, 
};
uint32_t ex4_param_10 = 1110;
uint32_t ex4_param_11 = 1929;
uint8_t ex4_param_2[10] = { 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30 };
uint8_t ex4_param_3[13] = { 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21 };

// 5: g(uint[][],string[])
ABI_t ex5_abi[2] = {
  { .type = ABI_UINT, .isArray = true, .extraDepth = 1 },
  { .type = ABI_STRING, .isArray = true }
};
uint8_t ex5_encoded[644] = {
  0x22, 0x89, 0xb1, 0x8c,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
  0x6f, 0x6e, 0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
  0x74, 0x77, 0x6f, 0x6f, 0x6f, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
  0x74, 0x68, 0x72, 0x65, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
uint8_t ex5_param_000[32] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
};
uint8_t ex5_param_001[32] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
};
uint8_t ex5_param_010[32] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
};
uint8_t ex5_param_10[4] = { 0x6f, 0x6e, 0x65, 0x64 };
uint8_t ex5_param_11[6] = { 0x74, 0x77, 0x6f, 0x6f, 0x6f, 0x6f };
uint8_t ex5_param_12[5] = { 0x74, 0x68, 0x72, 0x65, 0x65, };

// Examples created using `ethereumjs-abi`

// 6: f(uint32,string[][])
/*
uint8_t ex6_encoded[356] = {
  0x6c, 0xf6, 0x2b, 0xc5, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x55, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 
  0x66, 0x69, 0x72, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
  0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 
  0x74, 0x68, 0x69, 0x72, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
uint8_t ex6_param_0 = 8277;
uint8_t ex6_param_100 = { 0x66, 0x69, 0x72, 0x73, 0x74 };
uint8_t ex6_param_110 = { 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64 };
uint8_t ex6_param_111 = { 0x05, 0x74, 0x68, 0x69, 0x72, 0x64 };
*/
//===============================================================
// TESTS
//===============================================================

static inline uint32_t get_u32_be(uint8_t * in, size_t off) {
  return (in[off + 3] | in[off + 2] << 8 | in[off + 1] << 16 | in[off + 0] << 24);
}

static inline void test_ex1(uint8_t * out, size_t outSz) {
  ABISelector_t info = { .typeIdx = 0 };
  printf("Example 1...");
  // function baz(uint32 x, bool y)
  assert(abi_decode_param(out, outSz, ex1_abi, info, ex1_encoded+4) == sizeof(ex1_param_0));
  assert((out[3] | out[2] << 8 | out[1] << 16 | out[0] << 24) == ex1_param_0);
  memset(out, 0, outSz);
  info.typeIdx = 1;
  assert(abi_decode_param(out, outSz, ex1_abi, info, ex1_encoded+4) == sizeof(ex1_param_1));
  assert((bool) out[0] == ex1_param_1);
  memset(out, 0, outSz);
  printf("passed.\n\r");
}

static inline void test_ex2(uint8_t * out, size_t outSz) {
  ABISelector_t info = { .typeIdx = 0 };
  printf("Example 2...");
  // function bar(bytes3[2])
  info.typeIdx = 0;
  info.subIdx[0] = 0;
  assert(abi_decode_param(out, outSz, ex2_abi, info, ex2_encoded+4) == sizeof(ex2_param_00));
  assert(0 == memcmp(ex2_param_00, out, sizeof(ex2_param_00)));
  memset(out, 0, outSz);
  info.subIdx[0] = 1;
  assert(abi_decode_param(out, outSz, ex2_abi, info, ex2_encoded+4) == sizeof(ex2_param_01));
  assert(0 == memcmp(ex2_param_01, out, sizeof(ex2_param_01)));
  memset(out, 0, outSz);
  info.subIdx[0] = 0;
  printf("passed.\n\r");
}

static inline void test_ex3(uint8_t * out, size_t outSz) {
  ABISelector_t info = { .typeIdx = 0 };
  printf("Example 3...");
  // function sam(bytes, bool, uint[])
  assert(abi_decode_param(out, outSz, ex3_abi, info, ex3_encoded+4) == sizeof(ex3_param_0)); // 4 bytes in payload
  assert(0 == memcmp(ex3_param_0, out, sizeof(ex3_param_0)));
  memset(out, 0, outSz);
  info.typeIdx = 1;
  assert(abi_decode_param(out, outSz, ex3_abi, info, ex3_encoded+4) == sizeof(ex3_param_1)); // 1 byte for bool
  assert((bool) out[0] == ex3_param_1);
  memset(out, 0, outSz);
  info.typeIdx = 2;
  info.subIdx[0] = 0;
  assert(abi_decode_param(out, outSz, ex3_abi, info, ex3_encoded+4) == sizeof(ex3_param_20)); // 3 uint values, each 32 bytes
  assert(0 == memcmp(ex3_param_20, out, sizeof(ex3_param_20)));
  memset(out, 0, outSz);
  info.subIdx[0] = 1;
  assert(abi_decode_param(out, outSz, ex3_abi, info, ex3_encoded+4) == sizeof(ex3_param_21)); // 3 uint values, each 32 bytes
  assert(0 == memcmp(ex3_param_21, out, sizeof(ex3_param_21)));
  memset(out, 0, outSz);
  info.subIdx[0] = 2;
  assert(abi_decode_param(out, outSz, ex3_abi, info, ex3_encoded+4) == sizeof(ex3_param_22)); // 3 uint values, each 32 bytes
  assert(0 == memcmp(ex3_param_22, out, sizeof(ex3_param_22)));
  memset(out, 0, outSz);
  info.subIdx[0] = 0;
  printf("passed.\n\r");
}

static inline void test_ex4(uint8_t * out, size_t outSz) {
  ABISelector_t info = { .typeIdx = 0 };
  printf("Example 4...");
  // f(uint,uint32[],bytes10,bytes)
  info.typeIdx = 0;
  assert(abi_decode_param(out, outSz, ex4_abi, info, ex4_encoded+4) == sizeof(ex4_param_0)); // uint = uint256 = 32 bytes
  assert(0 == memcmp(ex4_param_0, out, sizeof(ex4_param_0)));
  memset(out, 0, outSz);
  info.typeIdx = 1;
  info.subIdx[0] = 0;
  assert(abi_decode_param(out, outSz, ex4_abi, info, ex4_encoded+4) == sizeof(ex4_param_10)); // uint32 (see payload)
  assert(get_u32_be(out, 0) == ex4_param_10);
  memset(out, 0, outSz);
  info.subIdx[0] = 1;
  assert(abi_decode_param(out, outSz, ex4_abi, info, ex4_encoded+4) == sizeof(ex4_param_11)); // uint32 (see payload)
  assert(get_u32_be(out, 0) == ex4_param_11);
  memset(out, 0, outSz);
  info.subIdx[0] =  0;
  info.typeIdx = 2;
  assert(abi_decode_param(out, outSz, ex4_abi, info, ex4_encoded+4) == sizeof(ex4_param_2)); // bytes10 = 10 bytes
  assert(0 == memcmp(ex4_param_2, out, sizeof(ex4_param_2)));
  memset(out, 0, outSz);
  info.typeIdx = 3;
  assert(abi_decode_param(out, outSz, ex4_abi, info, ex4_encoded+4) == sizeof(ex4_param_3)); // 0x0d = 13 bytes
  assert(0 == memcmp(ex4_param_3, out, sizeof(ex4_param_3)));
  memset(out, 0, outSz);
  printf("passed.\n\r");
}

static inline void test_ex5(uint8_t * out, size_t outSz) {
  ABISelector_t info = { .typeIdx = 0 };
  printf("Example 5...");
  // g(uint[][],string[])
  info.typeIdx = 0;
  assert(abi_decode_param(out, outSz, ex5_abi, info, ex5_encoded+4) == sizeof(ex5_param_000));
  assert(0 == memcmp(ex5_param_000, out, sizeof(ex5_param_000)));
  memset(out, 0, outSz);
  info.subIdx[1] = 1;
  assert(abi_decode_param(out, outSz, ex5_abi, info, ex5_encoded+4) == sizeof(ex5_param_001));
  assert(0 == memcmp(ex5_param_001, out, sizeof(ex5_param_001)));
  memset(out, 0, outSz);
  info.subIdx[0] = 1;
  info.subIdx[1] = 0;
  assert(abi_decode_param(out, outSz, ex5_abi, info, ex5_encoded+4) == sizeof(ex5_param_010));
  assert(0 == memcmp(ex5_param_010, out, sizeof(ex5_param_010)));
  memset(out, 0, outSz);
  // If we go outside of the array size we should get 0 bytes back
  info.subIdx[0] = 2;
  info.subIdx[1] = 0;
  assert(abi_decode_param(out, outSz, ex5_abi, info, ex5_encoded+4) == 0);
  memset(out, 0, outSz);
  info.subIdx[0] = 0;
  info.subIdx[1] = 2;
  assert(abi_decode_param(out, outSz, ex5_abi, info, ex5_encoded+4) == 0);
  memset(out, 0, outSz);
  // Now get the strings
  info.typeIdx = 1;
  info.subIdx[0] = 0;
  info.subIdx[1] = 0;
  assert(abi_decode_param(out, outSz, ex5_abi, info, ex5_encoded+4) == sizeof(ex5_param_10));
  assert(0 == memcmp(ex5_param_10, out, sizeof(ex5_param_10)));
  memset(out, 0, outSz);
  info.subIdx[0] = 1;
  assert(abi_decode_param(out, outSz, ex5_abi, info, ex5_encoded+4) == sizeof(ex5_param_11));
  assert(0 == memcmp(ex5_param_11, out, sizeof(ex5_param_11)));
  memset(out, 0, outSz);
  info.subIdx[0] = 2;
  assert(abi_decode_param(out, outSz, ex5_abi, info, ex5_encoded+4) == sizeof(ex5_param_12));
  assert(0 == memcmp(ex5_param_12, out, sizeof(ex5_param_12)));
  memset(out, 0, outSz);

  printf("passed.\n\r");
}

int main() {
  printf("=============================\n\r");
  printf(" RUNNING ABI TESTS...\n\r");
  printf("=============================\n\r");
  uint8_t out[200] = {0};
  // NOTE: We always add a 4-byte offset (e.g. `ex1_encoded+4`) to account for the function signature,
  // which is not part of the data we are trying to decode.
  // NOTE: The values we are checking come from the examples web page, but you can also validate them
  // manually from the payloads above.
  test_ex1(out, sizeof(out));
  test_ex2(out, sizeof(out));
  test_ex3(out, sizeof(out));
  test_ex4(out, sizeof(out));
  test_ex5(out, sizeof(out));
  
  printf("=============================\n\r");
  printf(" ALL ABI TESTS PASSING!\n\r");
  printf("=============================\n\r");
  
  return 0;
}
